"""
Erkfir's 8-key -> 2(4-Key) storyboard converter

This script will convert the 8-key map retrieved from the defined filepath
and map difficulty into a 2[4K] storyboarded version.

Note: 'Purple Long Notes' are currently not supported...
"""

import sys
import configparser
from StoryboardFunctions import *
 
config = configparser.ConfigParser()
config.read('config.ini')

# ================== Variables from config.ini ========================= #

DIFF = config["Map"]["Difficulty"]
FILEPATH = config["Map"]["Filepath"]
MAPNAME = config["Map"]["Mapname"]


# Skin [circle/bar/diamonds]
SKIN = config["Settings"]["Skin"]

# Choose the scroll speed from 25->35
RAW_SCROLL = int(config["Settings"]["Scroll"])

# Set the hitposition (higher than 480 = off screen)
RAW_HITPOS = int(config["Settings"]["Hitpos"])

# 0 = False 1 = True
UPSCROLL = bool(int(config["Settings"]["Upscroll"]))

# The X position of the field - 318 is what matches the provided skin
FIELD = int(config["Field"]["x-pos"])

FIELD_FADE_IN_START = int(config["Field"]["FadeInStart"])
FIELD_FADE_IN_FINISH = int(config["Field"]["FadeInFinish"])
FIELD_FADE_OUT_START = int(config["Field"]["FadeOutStart"])
FIELD_FADE_OUT_FINISH = int(config["Field"]["FadeOutFinish"])

RECEPTOR_FADE_IN_START = int(config["Receptor"]["FadeInStart"])
RECEPTOR_FADE_IN_FINISH = int(config["Receptor"]["FadeInFinish"])
RECEPTOR_FADE_OUT_START = int(config["Receptor"]["FadeOutStart"])
RECEPTOR_FADE_OUT_FINISH = int(config["Receptor"]["FadeOutFinish"])

# How far up off screen should the note spawn
if UPSCROLL is False:
    SPAWN_BUFFER = -int(config["Extra"]["SpawnBuffer"])
else:
    SPAWN_BUFFER = int(config["Extra"]["SpawnBuffer"])


# ======================================================================= #

FILENAME = f"{FILEPATH}{MAPNAME} [{DIFF}].osu"
OUTPUT = f"{FILEPATH}{MAPNAME}.osb"

MAGIC = 13720 # Literal magic number
SCROLL = 480 / (MAGIC / RAW_SCROLL)

# How early should the note spawn before when it hits the receptors
START_BUFFER = int(abs(SPAWN_BUFFER - RAW_HITPOS) / SCROLL)


if UPSCROLL is False:
    HIT_POS = RAW_HITPOS - 25 # half the size of the note image
else:
    HIT_POS = 480 - RAW_HITPOS + 25

LN_SCALE = (abs(SPAWN_BUFFER - HIT_POS) / START_BUFFER) # pixels per milisecond

# ================================ FILES =================================== #

SB_DIR = f"sb/{SKIN}/"
# Blue Notes
NOTE_B = f"{SB_DIR}note.png"
LN_B = f"{SB_DIR}ln1.png"
CAP_B = f"{SB_DIR}cap1.png"

# Red Notes
NOTE_R = f"{SB_DIR}note2.png"
LN_R = f"{SB_DIR}ln2.png"
CAP_R = f"{SB_DIR}cap2.png"

# Purple Note
NOTE_P = f"{SB_DIR}note3.png"

FIELD_FILE = f"{SB_DIR}field.png"
RECEPTOR_FILE = f"{SB_DIR}receptor.png"
RECEPTOR_COVER_FILE = f"{SB_DIR}receptorH.png"

# =============== Writing .osb formats ================== #
HEADER = "[Events]\n"
FOOTER = "// Generated by Erkfir's 2[4K] Storyboard converter"




# The X positions of the columns relative to the playfield
COL1 = FIELD - 90
COL2 = FIELD - 30
COL3 = FIELD + 30
COL4 = FIELD + 90

# 8-key column values
B1 = 32
B2 = 96
B3 = 160
B4 = 224

R1 = 288
R2 = 352
R3 = 416
R4 = 480


COLUMN = "column"
NOTE = "note"
LN = "ln"
CAP = "cap"

# The appropriate files depending on what column the note is in
NOTE_DATA = {
    B1: {COLUMN: COL1,
         NOTE:   NOTE_B,
         LN:     LN_B,
         CAP:    CAP_B},
    B2: {COLUMN: COL2,
         NOTE:   NOTE_B,
         LN:     LN_B,
         CAP:    CAP_B},
    B3: {COLUMN: COL3,
         NOTE:   NOTE_B,
         LN:     LN_B,
         CAP:    CAP_B},
    B4: {COLUMN: COL4,
         NOTE:   NOTE_B,
         LN:     LN_B,
         CAP:    CAP_B},
    R1: {COLUMN: COL1,
         NOTE:   NOTE_R,
         LN:     LN_R,
         CAP:    CAP_R},
    R2: {COLUMN: COL2,
         NOTE:   NOTE_R,
         LN:     LN_R,
         CAP:    CAP_R},
    R3: {COLUMN: COL3,
         NOTE:   NOTE_R,
         LN:     LN_R,
         CAP:    CAP_R},
    R4: {COLUMN: COL4,
         NOTE:   NOTE_R,
         LN:     LN_R,
         CAP:    CAP_R},
}




NOTE_COUNT = {
    f"{NOTE_B}" : [0, "Blue"],
    f"{NOTE_R}" : [0, "Red"],
    f"{NOTE_P}" : [0, "Purple"]
}


# ========================================================================= #




def read_file(filename):
    """
    Parses the give .osu file and returns a list of all the hitobject lines.
    """
    start = False
    infile = open(filename, 'r')
    lines = infile.readlines()
    note_lines = []
    
    for line in lines:
        line = line.strip("\n");
        if start is True:
            note_lines.append(line)
        elif line == "[HitObjects]":
            start = True

    infile.close()
    
    print(f"{len(note_lines)} total notes")
    
    return note_lines

def process_line(line, note_rows):
    """
    Processes the given hitobject line and parses it to be added to the note_rows
    list.
    
    The following tuple is what is added to the note_rows list:
    (start, end, column, note, length)
    
    start:    Start time of when the note should spawn in
    end:      End time of when the note should disappear. (The hit-time)
    column:   The x-position that the note should be at
    note:     The file name of the note sprite to be used
    length:   The length of the note in milliseconds or None if it's a rice note
    """
    col, _, end, _, _, extra = line.split(",")
    end = int(end)
    col = int(col)

    column = NOTE_DATA[col][COLUMN]
    note = NOTE_DATA[col][NOTE]
    ln = NOTE_DATA[col][LN]
    cap = NOTE_DATA[col][CAP]


    start = end - START_BUFFER

    extra = extra.split(":")


    if end not in note_rows:
        note_rows[end] = []


    if len(extra) > 5:
        tail = int(extra[0])
        length = tail - end
        note_rows[end].append((start, end, column, note, length))

    else:
        note_rows[end].append((start, end, column, note, None))


    return note_rows

def should_be_purple(note, notes):
    """
    Given a note and the list of notes at the same time, checks if the note is
    supposed to appear in the same column as another note at the same time.
    
    Will throw an exception if either or both of the notes are a long note.
    
    Returns True if it meets the conditions to be a purple note
    Returns False otherwise
    """
    start, end, col, note_file, length = note
    for start1, end1, col1, note_file1, length1 in notes:
        if note_file != note_file1 and col == col1:
            if length == None and length1 == None:
                return True
            else:
                raise Exception(f"Sorry but purple long notes aren't supported. Look at {end}ms")  
            
    return False
                
                
def already_exists_as_purple(note, processed_notes):
    """
    Checks if there is a purple note in the current column at this time
    """
    start, end, col, note_file, length = note
    if (start, end, col, NOTE_P, length) in processed_notes:
        return True
    return False


def process_notes(note_rows):
    """
    Takes the list of tuples of note data and processes it into a dictionary of
    processed notes.
    
    Will check for 'purple notes'
    
    Key: Integer of the millisecond time
    Value: List of tuples with information of each note
    
    (start, end, col, note, length)
    start:    Start time of when the note should spawn in
    end:      End time of when the note should disappear. (The hit-time)
    col:      The x-position that the note should be at
    note:     The file name of the note sprite to be used
    length:   The length of the note in milliseconds or None if it's a rice note
    
    """
    processed_notes = {}
    for time in note_rows:
        if time not in processed_notes:
            processed_notes[time] = []

        if len(note_rows[time]) == 1: # There is only one note at the particular time there is no need to check for purple notes
            start, end, col, note, length = note_rows[time][0]
            if length == None:
                processed_notes[time] = note_rows[time]
            else:
                processed_notes[time].append((start, end, col, note, length)) # head

        else:
            for note in note_rows[time]:
                start, end, col, note_file, length = note
                                
                
                if should_be_purple(note, note_rows[time]) and note not in processed_notes[time]:
                    if (not already_exists_as_purple(note, processed_notes[time])):
                        processed_notes[time].append((start, end, col, NOTE_P, length))
                else:
                    if length == None:
                        if (start, end, col, NOTE_P, length) not in processed_notes[time]:
                            processed_notes[time].append((start, end, col, note_file, length))
                    else:
                        processed_notes[time].append((start, end, col, note_file, length))     


    return processed_notes


def count_note(note_file):
    """Add to the global note count what note was used based on the file of the note"""
    try:
        NOTE_COUNT[note_file][0] = NOTE_COUNT[note_file][0] + 1
    except KeyError:
        pass



def write_receptors(outfile):
    """
    Write to the output file the lines for the receptor sprites
    """    
    for col in [COL1, COL2, COL3, COL4]:
        write_sprite_header(outfile, RECEPTOR_FILE)
        write_move(outfile, RECEPTOR_FADE_IN_START, RECEPTOR_FADE_OUT_FINISH, col, HIT_POS, col, HIT_POS)
        write_fade(outfile, RECEPTOR_FADE_IN_START, RECEPTOR_FADE_IN_FINISH, 0, 1)
        write_scale(outfile, RECEPTOR_FADE_IN_START, RECEPTOR_FADE_OUT_FINISH, 0.5, 0.5)
        write_fade(outfile, RECEPTOR_FADE_OUT_START, RECEPTOR_FADE_OUT_FINISH, 1, 0) 



def write_play_field(outfile):
    """
    Write to the output file the lines for the playfield sprite
    """
    write_sprite_header(outfile, FIELD_FILE)
    write_fade(outfile, FIELD_FADE_IN_START, FIELD_FADE_IN_FINISH, 0, 1)
    write_fade(outfile, FIELD_FADE_IN_FINISH, FIELD_FADE_IN_FINISH, 1, 1)
    write_move(outfile, FIELD_FADE_IN_START, FIELD_FADE_OUT_FINISH, FIELD, 240, FIELD, 240)
    write_fade(outfile, FIELD_FADE_OUT_START, FIELD_FADE_OUT_FINISH, 1, 0) 



def write_receptor_cover(outfile):
    """
    Write to the output file the lines for the receptor cover sprites
    """
    for col in [COL1, COL2, COL3, COL4]:
        write_sprite_header(outfile, RECEPTOR_COVER_FILE)
        write_move(outfile, RECEPTOR_FADE_IN_START, FIELD_FADE_OUT_FINISH, col, HIT_POS, col, HIT_POS)
        write_fade(outfile, RECEPTOR_FADE_IN_START, RECEPTOR_FADE_IN_FINISH, 0, 1)        
        write_fade(outfile, RECEPTOR_FADE_OUT_START, RECEPTOR_FADE_OUT_FINISH, 1, 0)
        
        if UPSCROLL is True:
            write_vertical_flip(outfile)


def write_osb_file(processed_notes, output_file):
    """
    Takes the dictionary of processed notes and will proceed to write the
    output .osb file.
    """
    outfile = open(output_file, 'w')
    
    outfile.write(HEADER)
    write_play_field(outfile)
    write_receptors(outfile)

    for time in processed_notes:
        for i in range(0, len(processed_notes[time])):
            start = processed_notes[time][i][0]
            end = processed_notes[time][i][1]
            column = processed_notes[time][i][2]
            note_file = processed_notes[time][i][3]
            length = processed_notes[time][i][4]


            if length != None:
                scale = (length * LN_SCALE)
                

                if note_file == NOTE_B:
                    write_sprite_header(outfile, CAP_B)
                    write_move(outfile, start + length, end + length, column, SPAWN_BUFFER, column, HIT_POS)
                    write_scale(outfile, start, end, 0.5, 0.5)

                    if UPSCROLL is True:
                        write_vertical_flip(outfile)

                    write_sprite_header(outfile, LN_B)
                    
                    if UPSCROLL is False:
                        write_move(outfile, start + length, end + length, column, SPAWN_BUFFER + ((length / 2) * LN_SCALE), column, HIT_POS + ((length / 2) * LN_SCALE))
                        
                    else:
                        write_move(outfile, start + length, end + length, column, SPAWN_BUFFER - ((length / 2) * LN_SCALE), HIT_POS  - ((length / 2) * LN_SCALE))
                    write_vertical_scale(outfile, start, end, 1, scale)

                    write_sprite_header(outfile, NOTE_B)
                    write_move(outfile, start, end, column, SPAWN_BUFFER, column, HIT_POS)
                    write_scale(outfile, start, end, 0.5, 0.5)

                    write_sprite_header(outfile, NOTE_B)
                    write_move(outfile, end, end + length, column, HIT_POS, column, HIT_POS)
                    write_scale(outfile, end, end + length, 0.5, 0.5)

                if note_file == NOTE_R:

                    write_sprite_header(outfile, CAP_R)
                    write_move(outfile, start + length, end + length, column, SPAWN_BUFFER, column, HIT_POS)
                    write_scale(outfile, start, end, 0.5, 0.5)

                    if UPSCROLL is True:
                        write_vertical_flip(outfile)

                    write_sprite_header(outfile, LN_R)
                    
                    if UPSCROLL is False:
                        write_move(outfile, start + length, end + length, column, SPAWN_BUFFER + ((length / 2) * LN_SCALE), column, HIT_POS  + ((length / 2) * LN_SCALE))
                    else:
                        write_move(outfile, start + length, end + length, column, SPAWN_BUFFER - ((length / 2) * LN_SCALE), column, HIT_POS  - ((length / 2) * LN_SCALE))
                    write_vertical_scale(outfile, start, end, 1, scale)
                    
                    write_sprite_header(outfile, NOTE_R)
                    write_move(outfile, start, end, column, SPAWN_BUFFER, column, HIT_POS)
                    write_scale(outfile, start, end, 0.5, 0.5)

                    write_sprite_header(outfile, NOTE_R)
                    write_move(outfile, end, end + length, column, HIT_POS, column, HIT_POS)
                    write_scale(outfile, end, end + length, 0.5, 0.5)

            else:
                write_sprite_header(outfile, note_file)
                write_move(outfile, start, end, column, SPAWN_BUFFER, column, HIT_POS)
                write_scale(outfile, start, end, 0.5, 0.5)

            count_note(note_file)

    write_receptor_cover(outfile)
    outfile.write(FOOTER)
    outfile.close()


def print_banner(message):
    """
    Simple method that sandwiches the message in between two lines of '=' symbols.
    """
    print("=" * 60)
    print(message)
    print("=" * 60)


def print_note_stats(note_rows):
    """
    Prints information on how many notes were used.
    """
    print(f"{len(note_rows)} rows of notes")

    print("\n[Notes Used]")
    for note in NOTE_COUNT:
        print(f"{NOTE_COUNT[note][1]} : {NOTE_COUNT[note][0]}")


def print_finished_info():
    """
    Prints some information about the map and settings used
    """
    print("\n[Information]")
    print("Map:", MAPNAME, f"[{DIFF}]")
    print("Skin used:", SKIN)
    print("Apprx. Scroll:", RAW_SCROLL, f"({SCROLL} pixels per millisecond)")
    print("Hitposition:", RAW_HITPOS)
    print("Upscroll:", UPSCROLL)


def main():
    """
    The main function
    """

    print_banner(f"Processing {FILENAME}")

    try:
        note_lines = read_file(FILENAME)
    except Exception as e:
        print(f"\nCould not read '{FILENAME}' : \n{e}\n")
        input("\nPress enter to exit...")
        
        sys.exit()

    note_rows = {}
    for line in note_lines:
        note_rows = process_line(line, note_rows)

    try:
        processed_notes = process_notes(note_rows)
    except Exception as error:
        print_banner("An error has occured...\n" + str(error))
        print("Conversion stopped. osb file not written.")
        input("\nPress enter to exit...")
        sys.exit()
    write_osb_file(processed_notes, OUTPUT)

    print_note_stats(note_rows)

    print_banner(f"'{OUTPUT}' file written!")
    print_finished_info()
    input("\nPress enter to exit...")


main()
